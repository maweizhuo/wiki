{"pages":[{"title":"About","date":"2017-11-29T06:57:57.000Z","path":"about/index.html","text":"who are you ? weizhuo.ma 😉 我是谁,芸芸众生中微不足道的那一个。。。 职业生涯 两年百度工作经验,(恐怕是工作中的人生巅峰了 😂 ) 其他小厂年限若干。。。 工作内容 后端PHP开发 LNMP Go,Python (自学中) 向往的生活 喜欢平凡, 追逐自由, 向往旅行 希望未来的某一天能和自己喜欢的人来一场说走就走的旅行 小诗结尾 如果失去是苦 你还怕不怕付出 如果坠落是苦 你还要不要幸福 如果迷乱是苦 再开始还是结束 如果追求是苦 这是坚强还是执迷不悟"},{"title":"Categories","date":"2017-11-20T09:36:00.000Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2017-11-20T09:36:00.000Z","path":"tags/index.html","text":""}],"posts":[{"title":"HTTP的变迁","date":"2018-03-14T01:51:30.000Z","path":"posts/HTTP的变迁/","text":"一张图看懂HTTP发展 http1.0 http1.0 早在1996年就出现了,基本满足了ajax的需求,但是毕竟刚出来不久,在优化上就得多下功夫,在http普及之后,他的缺点也开始展现出来。 http1.0最大的问题是关于tcp连接的问题,大家都知道tcp是连接型的协议,所以需要建立连接和断开连接。但是早期的http1.0只能在一个tcp上承载一个 http,而且web端只能有6-8个链接,这就使高并发的状态下宽带利用率非常低,所以在1999年推出了http1.1. http1.0与http1.1 下图表示了其主要区别 详细解释下: 缓存处理 在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag， If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。在这之中Etag也是最为重要的。它提供了精确的缓存定向。 可以精确缓存某个文件而不是根据日期全部缓存。浏览器缓存控制 宽带优化及网络连接的使用 HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能， HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。 错误通知的管理 在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。 Host头处理 Host头处理，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上 可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。 长连接 HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启 Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。 http与HTTPS https其实和http差不多，就是加了个s嘛，实质上也是，https是http上加了一层安全套接层 （SSL ：safe socket level），也就是这样。 http1.1 与SPDY http1.1还有几个明显的缺点， 一是会发生堵塞：请求到达的服务器的速度是不同的，如果先发的请求先到达可能会发生阻塞，这样带宽就降低了 二是不支持服务端推送，如果要求做一个服务端数据变动页面立即改变的组件就很难做。要用短轮询和长轮询。这样对带宽影响也是很大的。 … 所以，GOOGLE推出了SPDY。 SPDY是基于https的，也就是这样。 SPDY解决的问题还是很多的。具体如下: 降低延迟 针对HTTP高延迟的问题，SPDY优雅的采取了多路复用（multiplexing）。多路复用通过多个请求stream共享一个tcp连接的方式，解决了HOL blocking的问题，降低了延迟同时提高了带宽的利用率。 请求优先级 多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示， 之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。 header压缩 前面提到HTTP1.x的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。 基于HTTPS的加密协议传输，大大提高了传输数据的可靠性。 服务端推送（server push） 采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到， 不用再发请求了。 SPDY与http2 结果httpSPDY这么好用，基本上大家都在用，就基于SPDY推出了 http2.0,而且把SPDY的优势用在了http上,也就是可以不用加密也能使用。而且稍微的把头部压缩算法换了一换。 具体来说: HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS HTTP2.0 消息头的压缩算法采用 HPACK http://http2.github.io/http2-spec/compression.html， 而非 SPDY 采用的 DEFLATE http://zh.wikipedia.org/wiki/DEFLATE 引用 记录点滴，成为更好的自己。 — weizhuo.ma","tags":[{"name":"Http","slug":"Http","permalink":"http://wiki.maweizhuo.com/tags/Http/"}],"categories":[{"name":"编程艺术","slug":"编程艺术","permalink":"http://wiki.maweizhuo.com/categories/编程艺术/"},{"name":"HTTP","slug":"编程艺术/HTTP","permalink":"http://wiki.maweizhuo.com/categories/编程艺术/HTTP/"}]},{"title":"php 单例模式","date":"2018-02-09T08:53:30.000Z","path":"posts/php 单例模式/","text":"设计模式 设计模式一共貌似几十种。主要记录下PHP中常用单例模式 概念 单例模式：即一个类只被实例化一次，当其他人对其再次实例化时，便返回第一次实例化的对象。 这种模式可以极大地节约资源。典型应用于数据库类的实例化。 特点 1.外部不可以实例化，因此内部实例化函数的类型必须为静态，在类未实例化之前就已经初始化; 2.静态函数只能访问静态变量，所以定义private static $instance; 3.静态变量的访问写法为：类名::$变量名，在类内部可以直接写self:$instance； 4.可以用instanceof这个关键字检测变量中存放的是不是当前的类实例。 实现 三私一公 123456789101112131415161718192021222324252627&lt;?php //php下的单例模式 class Single &#123; private static $instance; //防止在外部进行 实例化 new Single private function __construct() &#123; &#125; public static function getInstance() &#123; if(self::$instance instanceof self) &#123; self::$instance =new self; &#125; return self::$instance; &#125; //防止被克隆 $b=clone $a private function __clone() &#123; &#125; &#125; 例子 单例类文件 :Danli.php 12345678910111213141516171819202122&lt;?php class Danli &#123; //保存类的实例的静态成员变量 static private $_instance=null; //私有的构造方法 private function __construct()&#123; echo \"这是一个构造方法&lt;br&gt;\"; &#125; //用于访问类的实例的公共的静态方法 static public function getInstance()&#123; if(!(self::$_instance instanceof Danli))&#123; echo \"实例化&lt;br&gt;\"; self::$_instance = new self; &#125; return self::$_instance; &#125; //类的其它方法 public function test()&#123; echo \"调用成功&lt;br&gt;\"; &#125; &#125; index.php 12345678910index.php &lt;?php //加载类文件 require \"Danli.php\"; //第一次调用类的实例 $first = Danli::getInstance(); $first-&gt;test(); //第二次调用类的实例 $second = Danli::getInstance(); $second-&gt;test(); 输出结果: 1234实例化这是一个构造方法调用成功调用成功 引用 记录点滴，成为更好的自己。 — weizhuo.ma","tags":[{"name":"php","slug":"php","permalink":"http://wiki.maweizhuo.com/tags/php/"},{"name":"rpc","slug":"rpc","permalink":"http://wiki.maweizhuo.com/tags/rpc/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://wiki.maweizhuo.com/categories/程序语言/"},{"name":"PHP","slug":"程序语言/PHP","permalink":"http://wiki.maweizhuo.com/categories/程序语言/PHP/"}]},{"title":"php rpc相关","date":"2018-01-23T06:53:30.000Z","path":"posts/php rpc相关/","text":"rpc概念 RPC（Remote Procedure Call）—远程过程调用，它是一种通过网络从远程计算机程序上请求服务， 而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP， 为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。 RPC使得开发包括网络分布式多程序在内的应用程序更加容易。 RPC采用客户机/服务器模式。请求程序就是一个客户机，而服务提供程序就是一个服务器。 首先，客户机调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。 在服务器端，进程保持睡眠状态直到调用信息到达为止。当一个调用信息到达，服务器获得进程参数， 计算结果，发送答复信息，然后等待下一个调用信息，最后，客户端调用进程接收答复信息，获得进程结果， 然后调用执行继续进行。 RPC与Socket有什么区别？ 好像RPC与Socket 好像啊。都是调用远程的方法，都是client/server模式， 那他们有啥区别呢? RPC（远程过程调用）采用客户机/服务器模式实现两个进程之间相互通信。 socket是RPC经常采用的通信手段之一，RPC是在Socket的基础上实现的，它比socket需要更多的网络和系统资源。 除了Socket，RPC还有其他的通信方法，比如：http、操作系统自带的管道等技术来实现对于远程程序的调用。 微软的Windows系统中，RPC就是采用命名管道进行通信。 RPC与REST有什么区别？ 通过了解RPC后，我们知道是RPC是client/server模式的，调用远程的方法， REST也是我们熟悉的一套API调用协议方法，它也是基于client/server模式的，调用远程的方法的， 那他俩又有啥区别呢？ REST API 和 RPC 都是在 Server端 把一个个函数封装成接口暴露出去，以供 Client端 调用，不过 REST API 是基于 HTTP协议 的，REST致力于通过http协议中的POST/GET/PUT/DELETE等方法和一个可读性强的URL来提供一个http请求。 而 RPC 则可以不基于 HTTP协议 因此，如果是后端两种语言互相调用， 用 RPC 可以获得更好的性能（省去了 HTTP 报头等一系列东西），应该也更容易配置。 如果是前端通过 AJAX 调用后端，那么用 REST API 的形式比较好（因为无论如何也避不开 HTTP 这道坎）。 php中流行的rpc框架有哪些 既然php是世界上最好的语言，那php中流行的RPC框架有哪些呢？ 先列举下： phprpc，yar, thrift, gRPC, swoole, hprose 因为时间和精力有限，不可能一个一个的去学习和使用，我选几个世面上用的最多的几个用下吧。 因为RPC原理是一样的，都是Client/Server模式，只是每个框架的使用方式不一样而已。 yar的简单使用 简介 yar 是国内著名的php大神鸟哥惠新宸的大作，在微博产品中已经开始使用。它也是一款rpc框架。 它由于使用纯C编写的用于php的扩展，所以，效率应该是蛮高的，而且支持异步并行，这点还是赞的。 下载 官网下载：http://pecl.php.net/package/yar 最新的版本 yar-1.2.4.tgz 然后解压复制到php源码的etx目录：/lamp/php-5.4.11/ext 下。然后用phpize进行扩展重新编译。 安装 123[root@localhost yar-1.2.4]# /usr/local/php/bin/phpize[root@localhost yar-1.2.4]# ./configure --with-php-config=/usr/local/php/bin/php-config 但是出现了点问题：提示，curl 有问题： configure: error: Please reinstall the libcurl distribution - easy.h should be in &lt;curl-dir&gt;/include/curl/ 估计是我本机curl 有问题，那用yum 安装一下吧： yum -y install curl-devel 安装完成curl 后继续编译安装，就没啥问题了： 1234[root@localhost yar-1.2.4]# /usr/local/php/bin/phpize[root@localhost yar-1.2.4]# ./configure --with-php-config=/usr/local/php/bin/php-config[root@localhost yar-1.2.4]# make &amp;&amp; make install 成功之后，提示我们 yar.so 扩展在已经在/usr/local/php/lib/php/extensions/no-debug-zts-20100525/ 下了。 我们vi编辑一下 php.ini ,最后面加上yar.so扩展，然后重启一下 apache 或者php-pfm就可以了。 1[root@localhost /]# vi /usr/local/php/etc/php.ini [yar]extension=yar.so 开始使用 和其他的rpc框架一样，yar也是server/client模式，所以，我们也一样，开始写一个简单的例子来说下如何调用。 yar_server.php 表示服务器端 12345678910111213141516171819&lt;?phpclass API &#123; public function api($parameter, $option = \"foo\") &#123; return $parameter; &#125; protected function client_can_not_see() &#123; &#125;&#125;$service = new Yar_Server(new API());$service-&gt;handle(); 好，我们在浏览器里运行一下，输出很高端啊！！！ 鸟哥说这样做的用途是可以一目了然的知道我这个rpc提供了多少接口，把api文档都可以省略了。 好，我们开始写yar_client.php 这个是客户端： 123$client = new Yar_Client(\"http://127.0.0.1/yar_server.php\");echo $client-&gt;api('helo word'); 好，像其他的 swoole，hprose等基本都是这个原理，只是看谁的功能更加，用起来更顺手罢了。 引用 记录点滴，成为更好的自己。 — weizhuo.ma","tags":[{"name":"php","slug":"php","permalink":"http://wiki.maweizhuo.com/tags/php/"},{"name":"rpc","slug":"rpc","permalink":"http://wiki.maweizhuo.com/tags/rpc/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://wiki.maweizhuo.com/categories/程序语言/"},{"name":"PHP","slug":"程序语言/PHP","permalink":"http://wiki.maweizhuo.com/categories/程序语言/PHP/"}]},{"title":"mac 工具软件常用快捷键","date":"2018-01-17T06:51:30.000Z","path":"posts/mac工具软件常用快捷键/","text":"介绍 记录下下Mac里常用软件的快捷键,避免总查询 phpstorm command + O 查找类名 command + shift + O 查找文件名 command + alt + o 查找function command + shift + f 全局查找内容 command + ` 多个打开的项目切换 command + alt + l 格式化选中代码 command + r 替换 command + d 复制选中的行 command + delete 删除选中行 command + l 跳转到指定行 command + e 打开最近活动的文件 control + tab 打开的文件切换 iterm 标签 123456789新建标签：command + t关闭标签：command + w切换标签：command + 数字 command + 左右方向键切换全屏：command + enter查找：command + f 分屏 123456789垂直分屏：command + d水平分屏：command + shift + d切换屏幕：command + option + 方向键 command + [ 或 command + ]查看历史命令：command + ;查看剪贴板历史：command + shift + h 其他 123456789101112131415161718192021222324252627282930313233343536373839404142434445清除当前行：ctrl + u到行首：ctrl + a到行尾：ctrl + e前进后退：ctrl + f/b (相当于左右方向键)上一条命令：ctrl + p搜索命令历史：ctrl + r删除当前光标的字符：ctrl + d删除光标之前的字符：ctrl + h删除光标之前的单词：ctrl + w删除到文本末尾：ctrl + k交换光标处文本：ctrl + t清屏1：command + r清屏2：ctrl + l自带有哪些很实用的功能/快捷键⌘ + 数字在各 tab 标签直接来回切换选择即复制 + 鼠标中键粘贴，这个很实用⌘ + f 所查找的内容会被自动复制⌘ + d 横着分屏 / ⌘ + shift + d 竖着分屏⌘ + r = clear，而且只是换到新一屏，不会想 clear 一样创建一个空屏ctrl + u 清空当前行，无论光标在什么位置输入开头命令后 按 ⌘ + ; 会自动列出输入过的命令⌘ + shift + h 会列出剪切板历史可以在 Preferences &gt; keys 设置全局快捷键调出 iterm，这个也可以用过 Alfred 实现 sequel pro command / 注释或者取消注释一行。 command +t 打开一个连接标签。 command +r 运行SQL。 引用 记录点滴，成为更好的自己。 — weizhuo.ma","tags":[{"name":"tool","slug":"tool","permalink":"http://wiki.maweizhuo.com/tags/tool/"}],"categories":[{"name":"工具软件","slug":"工具软件","permalink":"http://wiki.maweizhuo.com/categories/工具软件/"},{"name":"Mac","slug":"工具软件/Mac","permalink":"http://wiki.maweizhuo.com/categories/工具软件/Mac/"}]},{"title":"mongodb 增删改查","date":"2018-01-15T02:53:30.000Z","path":"posts/mongodb 增删改查/","text":"创建/删除数据库 创建 use DATABASE_NAME 如果数据库不存在，则创建数据库，否则切换到指定数据库。 MongoDB 中默认的数据库为 test，如果你没有创建新的数据库，集合将存放在 test 数据库中。 12345678910111213141516eg:&gt; use runoobswitched to db runoob&gt; dbrunoob&gt; **你想查看所有数据库，可以使用 show dbs 命令：**&gt; show dbslocal 0.078GBtest 0.078GB&gt; //可以看到，我们刚创建的数据库 runoob 并不在数据库的列表中，//要显示它，我们需要向 runoob 数据库插入一些数据。 删除数据库 db.dropDatabase() 12345678910111213&gt; show dbslocal 0.078GBrunoob 0.078GBtest 0.078GB&gt; use runoobswitched to db runoob&gt; &gt; db.dropDatabase()&#123; \"dropped\" : \"runoob\", \"ok\" : 1 &#125;&gt; show dbslocal 0.078GBtest 0.078GB&gt; 删除集合 mongo 里说的集合 = MySQL里的表 db.collection.drop() 123456789eg:&gt; use runoobswitched to db runoob&gt; show tablesuser&gt; db.user.drop()true&gt; show tables&gt; 插入文档 db.col.insert() db.collection.insertOne():向指定集合中插入一条文档数据 db.collection.insertMany():向指定集合中插入多条文档数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// insert() 插入,find() 查询, pretty()格式化&gt; db.user.insert(&#123;'id':1,'age':12,'name':'maweizhuo'&#125;)WriteResult(&#123; \"nInserted\" : 1 &#125;)&gt; db.user.find()&#123; \"_id\" : ObjectId(\"5a58163b9a948caad01e31b4\"), \"id\" : 1, \"age\" : 12, \"name\" : \"maweizhuo\" &#125;&gt; db.user.find().pretty()&#123; \"_id\" : ObjectId(\"5a58163b9a948caad01e31b4\"), \"id\" : 1, \"age\" : 12, \"name\" : \"maweizhuo\"&#125; // insertOne &gt; db.user.insertOne(&#123;'id':2,'age':13,'name':'maweizhuo1'&#125;)&#123; \"acknowledged\" : true, \"insertedId\" : ObjectId(\"5a581a159a948caad01e31b5\")&#125;&gt; db.user.find().pretty()&#123; \"_id\" : ObjectId(\"5a58163b9a948caad01e31b4\"), \"id\" : 1, \"age\" : 12, \"name\" : \"maweizhuo\"&#125;&#123; \"_id\" : ObjectId(\"5a581a159a948caad01e31b5\"), \"id\" : 2, \"age\" : 13, \"name\" : \"maweizhuo1\"&#125;// 插入多条记录&gt; db.user.insertMany([&#123;'id':4,'age':14,'name':'maweizhuo4'&#125;,&#123;'id':5,'age':15,'name':'maweizhuo5'&#125;])&#123; \"acknowledged\" : true, \"insertedIds\" : [ ObjectId(\"5a581aa39a948caad01e31b6\"), ObjectId(\"5a581aa39a948caad01e31b7\") ]&#125;&gt; db.user.find().pretty()&#123; \"_id\" : ObjectId(\"5a58163b9a948caad01e31b4\"), \"id\" : 1, \"age\" : 12, \"name\" : \"maweizhuo\"&#125;&#123; \"_id\" : ObjectId(\"5a581a159a948caad01e31b5\"), \"id\" : 2, \"age\" : 13, \"name\" : \"maweizhuo1\"&#125;&#123; \"_id\" : ObjectId(\"5a581aa39a948caad01e31b6\"), \"id\" : 4, \"age\" : 14, \"name\" : \"maweizhuo4\"&#125;&#123; \"_id\" : ObjectId(\"5a581aa39a948caad01e31b7\"), \"id\" : 5, \"age\" : 15, \"name\" : \"maweizhuo5\"&#125;&gt; 修改 MongoDB 使用 update() 和 save() 方法来更新集合中的文档 update 参数说明： query : update的查询条件，类似sql update查询内where后面的。 update : update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql update查询内set后面的 upsert : (update+insert)可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。 multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。 writeConcern :可选，抛出异常的级别。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&gt; db.users.insert(&#123;'name':'maweihzuo','age':18,'tag':['mongo','nosql']&#125;)WriteResult(&#123; \"nInserted\" : 1 &#125;)&gt; show tablesusers&gt; db.users.find().pretty()&#123; \"_id\" : ObjectId(\"5a59ac4bc52de95ef9c85bfd\"), \"name\" : \"maweihzuo\", \"age\" : 18, \"tag\" : [ \"mongo\", \"nosql\" ]&#125;&gt;// update----修改的数据没加$set标记,数据直接变为替换了,缺失name-----&gt; db.users.update(&#123;'age':18&#125;,&#123;'age':19,\"tag\":['mongo','mysql','nosql']&#125;)WriteResult(&#123; \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 &#125;)&gt; db.users.find().pretty()&#123; \"_id\" : ObjectId(\"5a59ac4bc52de95ef9c85bfd\"), \"age\" : 19, \"tag\" : [ \"mongo\", \"mysql\", \"nosql\" ]&#125;// $set修改字段;$inc新增字段// $set 如果新增字段不会报错// $inc 后面如果修改原有的字段会报错&gt;db.users.update(&#123;'age':20&#125;,&#123;$set:&#123;'age':21,\"tag\":['mongo','mysql','nosql'],'name':'ma11'&#125;&#125;,&#123;multi:true&#125;)&gt;db.users.update(&#123;'age':21&#125;,&#123;$inc:&#123;'sex':1&#125;&#125;,&#123;multi:true&#125;)&gt;// save() 经测试是存在则修改。不存在在添加// 存在与否由是根据_id 来进行唯一区分的&gt; db.users.save(&#123;\"age\":1&#125;)// 3.2 + 新特性updateOneupdateMany&gt; db.test_collection.updateOne(&#123;\"name\":\"abc\"&#125;,&#123;$set:&#123;\"age\":\"28\"&#125;&#125;)&gt; db.test_collection.updateMany(&#123;\"age\":&#123;$gt:\"10\"&#125;&#125;,&#123;$set:&#123;\"status\":\"xyz\"&#125;&#125;) – 更多示例update参数作用 123456789101112只更新第一条记录：db.col.update( &#123; \"count\" : &#123; $gt : 1 &#125; &#125; , &#123; $set : &#123; \"test2\" : \"OK\"&#125; &#125; );全部更新：db.col.update( &#123; \"count\" : &#123; $gt : 3 &#125; &#125; , &#123; $set : &#123; \"test2\" : \"OK\"&#125; &#125;,false,true );只添加第一条：db.col.update( &#123; \"count\" : &#123; $gt : 4 &#125; &#125; , &#123; $set : &#123; \"test5\" : \"OK\"&#125; &#125;,true,false );全部添加加进去:db.col.update( &#123; \"count\" : &#123; $gt : 5 &#125; &#125; , &#123; $set : &#123; \"test5\" : \"OK\"&#125; &#125;,true,true );全部更新：db.col.update( &#123; \"count\" : &#123; $gt : 15 &#125; &#125; , &#123; $inc : &#123; \"count\" : 1&#125; &#125;,false,true );只更新第一条记录：db.col.update( &#123; \"count\" : &#123; $gt : 10 &#125; &#125; , &#123; $inc : &#123; \"count\" : 1&#125; &#125;,false,false ); 删除文档 MongoDB remove() 函数是用来移除集合中的数据。 参数说明： query :（可选）删除的文档的条件。 justOne : （可选）如果设为 true 或 1，则只删除一个文档。 writeConcern :（可选）抛出异常的级别。 12// 好的习惯是先查询是否存在,在进行remove操作db.user.remove(&#123;\"name\":3&#125;) remove() 方法已经过时了，现在官方推荐使用 deleteOne() 和 deleteMany() 方法。 123456如删除集合下全部文档：db.inventory.deleteMany(&#123;&#125;)删除 status 等于 A 的全部文档：db.inventory.deleteMany(&#123; status : \"A\" &#125;)删除 status 等于 D 的一个文档：db.inventory.deleteOne( &#123; status: \"D\" &#125; ) 条件操作符 (&gt;) 大于 - $gt ----------greater than (&lt;) 小于 - $lt ----------less than (&gt;=) 大于等于 - $gte ----------greater than equal (&lt;= ) 小于等于 - $lte ----------less than equal (!=) 不等于 $ne ----------- not equal (=) 等于 $eq -------- equal 1234567891011121314151617&gt; db.user.find(&#123;&#125;,&#123;_id:0&#125;).pretty()&#123; \"names\" : 2, \"name\" : 34, \"named\" : 34, \"namedd\" : 34 &#125;&#123; \"names\" : 5, \"name\" : 40, \"named\" : 35, \"namedd\" : 36 &#125;&#123; \"names\" : 7, \"name\" : 45, \"named\" : 37, \"namedd\" : 38 &#125;&gt;&gt; db.user.find(&#123;names:&#123;$gte:5&#125;&#125;,&#123;_id:0&#125;).pretty()&#123; \"names\" : 5, \"name\" : 40, \"named\" : 35, \"namedd\" : 36 &#125;&#123; \"names\" : 7, \"name\" : 45, \"named\" : 37, \"namedd\" : 38 &#125;&gt;// name 字段&gt;1&amp; &lt;=5&gt; db.user.find(&#123;names:&#123;$lte:5,$gt:1&#125;&#125;,&#123;_id:0&#125;).pretty()&#123; \"names\" : 2, \"name\" : 34, \"named\" : 34, \"namedd\" : 34 &#125;&#123; \"names\" : 5, \"name\" : 40, \"named\" : 35, \"namedd\" : 36 &#125;&gt;&gt; db.user.find(&#123;names:&#123;$lte:5,$gt:1&#125;,named:34&#125;,&#123;_id:0&#125;).pretty()&#123; \"names\" : 2, \"name\" : 34, \"named\" : 34, \"namedd\" : 34 &#125;&gt; limit 与 skip 操作符 我们除了可以使用limit()方法来读取指定数量的数据外， 还可以使用skip()方法来跳过指定数量的数据，skip方法同样接受一个数字参数作为跳过的记录条数。 当查询时同时使用sort,skip,limit，无论位置先后，最先执行顺序 sort再skip再limit。 123456789101112131415&gt; db.user.find(&#123;&#125;,&#123;_id:0&#125;).pretty()&#123; \"names\" : 2, \"name\" : 34, \"named\" : 34, \"namedd\" : 34 &#125;&#123; \"names\" : 5, \"name\" : 40, \"named\" : 35, \"namedd\" : 36 &#125;&#123; \"names\" : 7, \"name\" : 45, \"named\" : 37, \"namedd\" : 38 &#125;&gt;&gt; db.user.find(&#123;&#125;,&#123;_id:0&#125;).limit(2).pretty()&#123; \"names\" : 2, \"name\" : 34, \"named\" : 34, \"namedd\" : 34 &#125;&#123; \"names\" : 5, \"name\" : 40, \"named\" : 35, \"namedd\" : 36 &#125;&gt;&gt; db.user.find(&#123;&#125;,&#123;_id:0&#125;).skip(1).limit(2).pretty()&#123; \"names\" : 5, \"name\" : 40, \"named\" : 35, \"namedd\" : 36 &#125;&#123; \"names\" : 7, \"name\" : 45, \"named\" : 37, \"namedd\" : 38 &#125;&gt; db.user.find(&#123;&#125;,&#123;_id:0&#125;).skip(2).limit(2).pretty()&#123; \"names\" : 7, \"name\" : 45, \"named\" : 37, \"namedd\" : 38 &#125;&gt; 排序 sort()方法可以通过参数指定排序的字段， 并使用 1 和 -1 来指定排序的方式，其中1 为升序排列，而-1是用于降序排列。 1234567891011121314&gt; db.user.find(&#123;&#125;,&#123;_id:0&#125;).pretty()&#123; \"names\" : 2, \"name\" : 34, \"named\" : 34, \"namedd\" : 34 &#125;&#123; \"names\" : 5, \"name\" : 40, \"named\" : 35, \"namedd\" : 36 &#125;&#123; \"names\" : 7, \"name\" : 45, \"named\" : 37, \"namedd\" : 38 &#125;&gt;&gt; db.user.find(&#123;&#125;,&#123;_id:0&#125;).sort(&#123;name:-1&#125;).pretty()&#123; \"names\" : 7, \"name\" : 45, \"named\" : 37, \"namedd\" : 38 &#125;&#123; \"names\" : 5, \"name\" : 40, \"named\" : 35, \"namedd\" : 36 &#125;&#123; \"names\" : 2, \"name\" : 34, \"named\" : 34, \"namedd\" : 34 &#125;&gt; db.user.find(&#123;&#125;,&#123;_id:0&#125;).sort(&#123;name:-1,name:1&#125;).pretty()&#123; \"names\" : 2, \"name\" : 34, \"named\" : 34, \"namedd\" : 34 &#125;&#123; \"names\" : 5, \"name\" : 40, \"named\" : 35, \"namedd\" : 36 &#125;&#123; \"names\" : 7, \"name\" : 45, \"named\" : 37, \"namedd\" : 38 &#125;&gt; 索引 背景 索引通常能够极大的提高查询的效率，如果没有索引， MongoDB在读取数据时必须扫描集合中的每个文件并选取那些符合查询条件的记录。 这种扫描全集合的查询效率是非常低的，特别在处理大量的数据时，查询可以要花费几十秒甚至几分钟， 这对网站的性能是非常致命的。 索引是特殊的数据结构，索引存储在一个易于遍历读取的数据集合中，索引是对数据库表中一列或多列的值进行排序的一种结构 语法 &gt;db.COLLECTION_NAME.ensureIndex({KEY:1}) 语法中 Key 值为你要创建的索引字段，1为指定按升序创建索引，如果你想按降序来创建索引指定为-1即可。 有几个可选参数设置后台执行,唯一索引等。详情看教程 12345678// 单个索引 &gt;db.col.ensureIndex(&#123;\"title\":1&#125;) &gt; // ensureIndex() 方法中你也可以设置使用多个字段创建索引（关系型数据库中称作复合索引）。 &gt;db.col.ensureIndex(&#123;\"title\":1,\"description\":-1&#125;) &gt; // 在后台创建索引 db.values.ensureIndex(&#123;open: 1, close: 1&#125;, &#123;background: true&#125;) 聚合 背景 MongoDB中聚合(aggregate)主要用于处理数据(诸如统计平均值,求和等)， 并返回计算后的数据结果。有点类似sql语句中的 count(*)。 语法 &gt;db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION) 常用的聚合表达式 $sum,$avg,$max,$min,$first,$last 123456789101112131415161718&gt; db.user.find(&#123;&#125;,&#123;_id:0&#125;).pretty()&#123; \"names\" : 2, \"name\" : \"martin1\", \"named\" : 34, \"namedd\" : 34 &#125;&#123; \"names\" : 5, \"name\" : \"martin2\", \"named\" : 35, \"namedd\" : 36 &#125;&#123; \"names\" : 7, \"name\" : \"martin1\", \"named\" : 37, \"namedd\" : 38 &#125;&gt;&gt; db.user.aggregate([&#123;$group:&#123;_id:\"$name\", num_tutorial : &#123;$sum:1&#125;&#125;&#125;])&#123; \"_id\" : \"martin2\", \"num_tutorial\" : 1 &#125;&#123; \"_id\" : \"martin1\", \"num_tutorial\" : 2 &#125;&gt;&gt; db.user.aggregate([&#123;$group:&#123;_id:\"$name\", num_tutorial : &#123;$sum:\"$names\"&#125;&#125;&#125;])&#123; \"_id\" : \"martin2\", \"num_tutorial\" : 5 &#125;&#123; \"_id\" : \"martin1\", \"num_tutorial\" : 9 &#125;&gt; db.user.aggregate([&#123;$group:&#123;_id:\"$name\", num_tutorial : &#123;$min:\"$names\"&#125;&#125;&#125;])&#123; \"_id\" : \"martin2\", \"num_tutorial\" : 5 &#125;&#123; \"_id\" : \"martin1\", \"num_tutorial\" : 2 &#125;&gt; db.user.aggregate([&#123;$group:&#123;_id:\"$name\", num_tutorial : &#123;$min:\"$named\"&#125;&#125;&#125;])&#123; \"_id\" : \"martin2\", \"num_tutorial\" : 35 &#125;&#123; \"_id\" : \"martin1\", \"num_tutorial\" : 34 &#125; 管道 管道在Unix和Linux中一般用于将当前命令的输出结果作为下一个命令的参数。 MongoDB的聚合管道将MongoDB文档在一个管道处理完毕后将结果传递给下一个管道处理。管道操作是可以重复的。 表达式：处理输入文档并输出。表达式是无状态的，只能用于计算当前聚合管道的文档，不能处理其它的文档。 这里我们介绍一下聚合框架中常用的几个操作： $project：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。 $match：用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。 $limit：用来限制MongoDB聚合管道返回的文档数。 $skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。 $unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。 $group：将集合中的文档分组，可用于统计结果。 $sort：将输入文档排序后输出。 $geoNear：输出接近某一地理位置的有序文档。 123456789101112131415161718&gt; db.user.aggregate([&#123;$project:&#123;name:1,named:1&#125;&#125;])&#123; \"_id\" : ObjectId(\"5a59d48084421d11551bb6a0\"), \"name\" : \"martin1\", \"named\" : 34 &#125;&#123; \"_id\" : ObjectId(\"5a5c0f172a78de2cabb5ad27\"), \"name\" : \"martin2\", \"named\" : 35 &#125;&#123; \"_id\" : ObjectId(\"5a5c11e42a78de2cabb5ad28\"), \"name\" : \"martin1\", \"named\" : 37 &#125;&gt; db.user.aggregate([&#123;$project:&#123;_id:0&#125;&#125;])&#123; \"names\" : 2, \"name\" : \"martin1\", \"named\" : 34, \"namedd\" : 34 &#125;&#123; \"names\" : 5, \"name\" : \"martin2\", \"named\" : 35, \"namedd\" : 36 &#125;&#123; \"names\" : 7, \"name\" : \"martin1\", \"named\" : 37, \"namedd\" : 38 &#125;&gt; db.user.aggregate([&#123;$match:&#123;named:&#123;$lte:37,$gte:34&#125;&#125;&#125;,&#123;$group:&#123;_id:\"$name\",num:&#123;$sum:1&#125;&#125;&#125;])&#123; \"_id\" : \"martin2\", \"num\" : 1 &#125;&#123; \"_id\" : \"martin1\", \"num\" : 2 &#125;// $match用于获取named大于34小于或等于37记录，然后将符合条件的记录送到下一阶段$group管道操作符进行处理。&gt; db.user.aggregate([&#123;$match:&#123;named:&#123;$lte:37,$gte:34&#125;&#125;&#125;,&#123;$group:&#123;_id:null,num:&#123;$sum:1&#125;&#125;&#125;])&#123; \"_id\" : null, \"num\" : 3 &#125;// 跳过第一个,聚合操作&gt; db.user.aggregate([&#123;$skip:1&#125;,&#123;$group:&#123;_id:\"$name\",num:&#123;$sum:1&#125;&#125;&#125;])&#123; \"_id\" : \"martin1\", \"num\" : 1 &#125;&#123; \"_id\" : \"martin2\", \"num\" : 1 &#125; mongodb使用参考 可参考文章mongodb使用教程 引用 记录点滴，成为更好的自己。 — weizhuo.ma","tags":[{"name":"mongodb","slug":"mongodb","permalink":"http://wiki.maweizhuo.com/tags/mongodb/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://wiki.maweizhuo.com/categories/程序语言/"},{"name":"NOSQL","slug":"程序语言/NOSQL","permalink":"http://wiki.maweizhuo.com/categories/程序语言/NOSQL/"}]},{"title":"mongodb安装配置及启动","date":"2018-01-10T07:53:30.000Z","path":"posts/mongodb安装配置及启动/","text":"linux 安装 123456curl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.6.2.tgz # 下载tar -zxvf mongodb-linux-x86_64-3.6.2.tgz # 解压mv mongodb-linux-x86_64-3.6.2/ /usr/local/mongodb # 将解压包拷贝到指定目录export PATH= /usr/local/mongodb/bin:$PATH 配置 yum 安装的配置文件在/etc/mongodb.conf 123456789101112修改为如下:dbpath=/data/mongo/logpath=/data/mongo/mongo.loglogappend=truefork=trueport=27017非yum 安装的可以指定位置写入配置文件,启动时候指向该文件即可 启动 配置文件方式启动 123# bin/mongod -f /data/mongo/mongodb.cnf或者 # bin/mongod -f /data/mongo/mongodb.cnf &amp; （放到后台执行） 参数启动mongo 12345 bin/mongod -dbpath /data/mongo/ -logpath /data/mongo/mongo.log -logappend -fork -port 27017 终端输出： all output going to: /data/mongo/mongo.log PHP安装扩展 php5 版本 1234567git clone https://github.com/mongodb/mongo-php-driver.gitcd mongo-php-driver git submodule sync &amp;&amp; git submodule update --init /usr/local/php/bin/phpize ./configure --with-php-config=/usr/local/php/bin/php-config make sudo make install php7 版本 /usr/local/php7/bin/pecl install mongodb 然后修改php.ini extension=mongo.so 重启php-fpm或Apache 登录 123# mongoMongoDB shell version: 2.4.14connecting to: test mongodb与mysql对比 可参考文章mongodb与mysql深入对比 引用 记录点滴，成为更好的自己。 — weizhuo.ma","tags":[{"name":"nosql","slug":"nosql","permalink":"http://wiki.maweizhuo.com/tags/nosql/"},{"name":"mongodb","slug":"mongodb","permalink":"http://wiki.maweizhuo.com/tags/mongodb/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://wiki.maweizhuo.com/categories/程序语言/"},{"name":"NOSQL","slug":"程序语言/NOSQL","permalink":"http://wiki.maweizhuo.com/categories/程序语言/NOSQL/"}]},{"title":"Nosql与Sql对比","date":"2018-01-10T04:53:30.000Z","path":"posts/Nosql与Sql对比/","text":"关系型数据库发展史 在现代的计算系统上每天网络上都会产生庞大的数据量。 这些数据有很大一部分是由关系数据库管理系统（RDMBS）来处理。 1970年 E.F.Codd’s提出的关系模型的论文 “A relational model of data for large shared data banks”， 这使得数据建模和应用程序编程更加简单。 通过应用实践证明，关系模型是非常适合于客户服务器编程，远远超出预期的利益， 今天它是结构化数据存储在网络和商务应用的主导技术。 关系型数据库遵循ACID规则 事务在英文中是transaction，和现实世界中的交易很类似，它有如下四个特性： 1、A (Atomicity) 原子性 2、C (Consistency) 一致性 3、I (Isolation) 独立性 4、D (Durability) 持久性 什么是NoSQL? NoSQL，指的是非关系型的数据库。NoSQL有时也称作Not Only SQL的缩写，是对不同于传统的关系型数据库的 数据库管理系统的统称。 NoSQL用于超大规模数据的存储。（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。 这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。 为什么使用NoSQL ? 今天我们可以通过第三方平台（如：Google,Facebook等）可以很容易的访问和抓取数据。 用户的个人信息，社交网络，地理位置，用户生成的数据和用户操作日志已经成倍的增加。 我们如果要对这些用户数据进行挖掘，那SQL数据库已经不适合这些应用了, NoSQL数据库的发展也却能很好的处理这些大的数据。 RDBMS vs NoSQL RDBMS NoSQL 高度组织化结构化数据 代表着不仅仅是SQL 结构化查询语言（SQL） (SQL) 没有声明性查询语言 数据和关系都存储在单独的表中。 没有预定义的模式 数据操纵语言，数据定义语言 键 - 值对存储，列存储，文档存储，图形数据库 严格的一致性 最终一致性，而非ACID属性 基础事务 CAP定理 高性能，高可用性和可伸缩性 NoSQL 简史 NoSQL一词最早出现于1998年，是Carlo Strozzi开发的一个轻量、开源、不提供SQL功能的关系数据库。 2009年，Last.fm的Johan Oskarsson发起了一次关于分布式开源数据库的讨论， 来自Rackspace的Eric Evans再次提出了NoSQL的概念，这时的NoSQL主要指非关系型、分布式、不提供ACID的数据库设计模式。 2009年在亚特兰大举行的&quot;no:sql(east)“讨论会是一个里程碑，其口号是 &quot;select fun, profit from real_world where relational=false;”。 因此，对NoSQL最普遍的解释是&quot;非关联型的&quot;，强调Key-Value Stores和文档数据库的优点，而不是单纯的反对RDBMS。 CAP定理（CAP theorem） 在计算机科学中, CAP定理（CAP theorem）, 又被称作 布鲁尔定理（Brewer's theorem）, 它指出对于一个分布式计算系统来说，不可能同时满足以下三点: 一致性(Consistency) (所有节点在同一时间具有相同的数据) 可用性(Availability) (保证每个请求不管成功或者失败都有响应) 分隔容忍(Partition tolerance) (系统中任意信息的丢失或失败不会影响系统的继续运作) CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。 因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三 大类： CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。 CP - 满足一致性，分区容忍性的系统，通常性能不是特别高。 AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些 NoSQL的优点/缺点 优点 缺点 高可扩展性 没有标准化 分布式计算 有限的查询功能（到目前为止） 低成本 最终一致是不直观的程序 架构的灵活性，半结构化数据 没有复杂的关系 BASE BASE：Basically Available, Soft-state, Eventually Consistent。 由 Eric Brewer 定义。 BASE是NoSQL数据库通常对可用性及一致性的弱要求原则: Basically Availble --基本可用 Soft-state --软状态/柔性事务。 “Soft state” 可以理解为&quot;无连接&quot;的, 而 “Hard state” 是&quot;面向连接&quot;的 Eventual Consistency --最终一致性 最终一致性， 也是是 ACID 的最终目的。 ACID vs BASE ACID BASE 原子性(Atomicity) 基本可用(Basically Available) 一致性(Consistency) 软状态/柔性事务(Soft state) 隔离性(Isolation) 最终一致性 (Eventual consistency) 持久性 (Durable) NoSQL 数据库分类 类型 部分代表 特点 列存储 Hbase;Cassandra;Hypertable 顾名思义，是按列存储数据的。最大的特点是方便存储结构化和半结构化数据，方便做数据压缩，对针对某一列或者某几列的查询有非常大的IO优势。 文档存储 MongoDB;CouchDB 文档存储一般用类似json的格式存储，存储的内容是文档型的。这样也就有有机会对某些字段建立索引，实现关系数据库的某些功能。 key-value存储 Tokyo Cabinet / Tyrant;Berkeley DB;MemcacheDB;Redis 可以通过key快速查询到其value。一般来说，存储不管value的格式，照单全收。（Redis包含了其他功能） 图存储 Neo4J,FlockDB 图形关系的最佳存储。使用传统关系数据库来解决的话性能低下，而且设计使用不方便。 对象存储 db4o,Versant 通过类似面向对象语言的语法操作数据库，通过对象的方式存取数据。 xml数据库 Berkeley DB XML;BaseX 高效的存储XML数据，并支持XML的内部查询语法，比如XQuery,Xpath。 引用 记录点滴，成为更好的自己。 — weizhuo.ma","tags":[{"name":"nosql","slug":"nosql","permalink":"http://wiki.maweizhuo.com/tags/nosql/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://wiki.maweizhuo.com/categories/程序语言/"},{"name":"NOSQL","slug":"程序语言/NOSQL","permalink":"http://wiki.maweizhuo.com/categories/程序语言/NOSQL/"}]},{"title":"B树概念","date":"2018-01-09T08:53:30.000Z","path":"posts/B树概念/","text":"背景 mysql 使用的再多不过了,数据库索引内部实现的多数用的是B+树,但我对这个树的概念 及背后的算法,可以说是一点不了解,主要了解其定义,及算法实现。网上查了下记录如下。 参考文章 http://www.cnblogs.com/tgycoder/p/5077017.html 分类 B树(B-树) B+树 B*树 前言 动态查找树主要有：二叉查找树（Binary Search Tree），平衡二叉查找树（Balanced Binary Search Tree）， 红黑树(Red-Black Tree )，B-tree/B±tree/ B*-tree (B~Tree)。前三者是典型的二叉查找树结构， 其查找的时间复杂度O(log2N)与树的深度相关，那么降低树的深度自然会提高查找效率。 但是咱们有面对这样一个实际问题：就是大规模数据存储中，实现索引查询这样一个实际背景下， 树节点存储的元素数量是有限的（如果元素数量非常多的话，查找就退化成节点内部的线性查找了）， 这样导致二叉查找树结构由于树的深度过大而造成磁盘I/O读写过于频繁， 进而导致查询效率低下（为什么会出现这种情况，待会在外部存储器-磁盘中有所解释）， 那么如何减少树的深度（当然是不能减少查询的数据量），一个基本的想法就是：采用多叉树结构 （由于树节点元素数量是有限的，自然该节点的子树数量也就是有限的）。 也就是说，因为磁盘的操作费时费资源，如果过于频繁的多次查找势必效率低下。 那么如何提高效率，即如何避免磁盘过于频繁的多次查找呢？根据磁盘查找存取的次数往往由树的高度所决定，所以， 只要我们通过某种较好的树结构减少树的结构尽量减少树的高度，那么是不是便能有效减少磁盘查找存取的次数呢？ 那这种有效的树结构是一种怎样的树呢？ 这样我们就提出了一个新的查找树结构——多路查找树。根据平衡二叉树的启发，自然就想到平衡多路查找树结构， 也就是这篇文章所要阐述的第一个主题B~tree，即B树结构(后面，我们将看到，B树的各种操作能使B树保持较低的高度， 从而达到有效避免磁盘过于频繁的查找存取操作，从而有效提高查找效率)。 B树定义 B树是为了磁盘或其它存储设备而设计的一种多叉平衡查找树，与红黑树很相似。但是也存在一些不同。 B树与红黑树最大的不同在于，B树的结点可以有多个子女，从几个到上千个。 那为什么又说B树与红黑树很相似呢?因为与红黑树一样，一棵含n个结点的B树的高度也为O（lgn） ，但可能比一棵红黑树的高度小许多，因为它的分支因子比较大。所以，B树可以在O（logn）时间内， 实现各种如插入（insert），删除（delete）等动态集合操作。 (我的简单理解就是树的单层节点多了,更容易操作) 如下图所示，即是一棵B树，一棵关键字为英语中辅音字母的B树，现在要从树种查找字母R （包含n[x]个关键字的内结点x，x有n[x]+1]个子女（也就是说，一个内结点x若含有n[x]个关键字， 那么x将含有n[x]+1个子女）。所有的叶结点都处于相同的深度，带阴影的结点为查找字母R时要检查的结点）： B树节点定义 B+树 B+树是应文件系统所需而产生的一种B-tree的变形树 一棵m阶的B+树和m阶的B树的异同点在于： 有n棵子树的结点中含有n-1 个关键字； (此处颇有争议，B+树到底是与B 树n棵子树有n-1个关键字 保持一致，还是不一致：B树n棵子树的结点中含有n个关键字， 待后续查证。暂先提供两个参考链接：①wikipedia http://en.wikipedia.org/wiki/B%2B_tree#Overview； ②http://hedengcheng.com/?p=525。而下面B+树的图尚未最终确定是否有问题，请读者注意) 所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针， 且叶子结点本身依关键字的大小自小而大的顺序链接。 (而B 树的叶子节点并没有包括全部需要查找的信息) 所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息) 为什么说B+-tree比B 树更适合实际应用中操作系统的文件索引和数据库索引？ 1）B+树的磁盘读写代价更低 B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对于B树更小。如果把所有同一内部结点的关键字存放在 同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。 相对来说IO读写次数也就降低了。 举个例子，假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes，一个关键字具体信息指针2bytes。 一棵9阶B-tree(一个结点最多8个关键字)的内部结点需要2个盘快。而B+ 树内部结点只需要1个盘快。 当需要把内部结点读入内存中的时候，B 树就比B+ 树多一次盘块查找时间(在磁盘中就是盘片旋转的时间)。 B±tree的查询效率更加稳定 由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。 所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。 个人觉得这两个原因都不是主要原因。数据库索引采用B+树的主要原因是 B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。 正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。 而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）。 B*-tree B*-tree是B+-tree的变体，在B+树的基础上(所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针)， B树中非根和非叶子结点再增加指向兄弟的指针；B树定义了非叶子结点关键字个数至少为(2/3)*M， 即块的最低使用率为2/3（代替B+树的1/2）。给出了一个简单实例，如下图所示： 总结 通过以上介绍，大致将B树，B+树，B*树总结如下： B树：有序数组+平衡多叉树； B+树：有序数组链表+平衡多叉树； B*树：一棵丰满的B+树。 B+树还有一个最大的好处，方便扫库，B树必须用中序遍历的方法按序扫库， 而B+树直接从叶子结点挨个扫一遍就完了，B+树支持range-query非常方便，而B树不支持。 这是数据库选用B+树的最主要原因。 mysql 底层存储是用B+树实现的，知道为什么么。内存中B+树是没有优势的，但是一到磁盘，B+树的威力就出来了 引用 记录点滴，成为更好的自己。 — weizhuo.ma","tags":[{"name":"mysql","slug":"mysql","permalink":"http://wiki.maweizhuo.com/tags/mysql/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://wiki.maweizhuo.com/categories/程序语言/"},{"name":"MYSQL","slug":"程序语言/MYSQL","permalink":"http://wiki.maweizhuo.com/categories/程序语言/MYSQL/"}]},{"title":"HTTP 状态码","date":"2018-01-08T01:51:30.000Z","path":"posts/HTTP 状态码/","text":"一张图看懂HTTP状态码 引用 记录点滴，成为更好的自己。 — weizhuo.ma","tags":[{"name":"Http","slug":"Http","permalink":"http://wiki.maweizhuo.com/tags/Http/"}],"categories":[{"name":"编程艺术","slug":"编程艺术","permalink":"http://wiki.maweizhuo.com/categories/编程艺术/"},{"name":"HTTP","slug":"编程艺术/HTTP","permalink":"http://wiki.maweizhuo.com/categories/编程艺术/HTTP/"}]},{"title":"大型网站架构演化","date":"2018-01-08T01:51:30.000Z","path":"posts/大型网站架构演化/","text":"特点 高并发 大流量 高可用 海量数据 … 初始阶段 一台服务器搞定一个网站 应用服务和数据服务分离 使用缓存 现在的网站基本上都会使用缓存，即：80%的业务访问都会集中在20%的数据上。 服务器集群及读写分离 因为单一应用服务器能够处理的请求连接有限，在网站访问高峰时期，应用服务器会成为整个网站的瓶颈。 因此使用负载均衡处理器势在必然。通过负载均衡调度服务器， 可将来自浏览器的访问请求分发到应用的集群中的任何一台服务器上。 当用户达到一定规模后，数据库因为负载压力过高而成为网站的瓶颈。 而目前主流的数据库都提供主从热备功能，通过配置两台数据库主从关系， 可以将一台数据库的数据更新同步到另一台服务器上。 网站利用数据库这一功能实现数据库读写分离，从而改善数据库负载压力。 使用反向代理和CDN加速网站相应 提高网站的访问速度，主要手段有使用CDN和反向代理。 CDN和反向代理的基本原理都是缓存，区别在于CDN部署在网络提供商的机房， 而反向代理是部署在网站的中心机房，当用户请求到达中心机房后，首先访问的反向代理， 如果反向代理缓存着用户请求的资源，则直接返回给用户。 分布式文件系统和数据库系统 任何强大的单一服务器都满足不了大型网站持续增长的业务需求。 分布式数据库时网站数据库拆分的最后手段，只用在单表数据规模非常大的时候才使用。 不到不得已时，网站更常用的数据库拆分手段是业务拆分，将不同业务的数据部署在不同的物理服务器上。 使用NoSQL和搜索引擎 业务拆分 大型网站为了应对日益复杂的业务场景，通过使用分而治之的手段将真个网站业务拆分成不同的产品线。 具体到技术上，也会根据产品线话费，将一个网站拆分成许多不同的应用，每个应用独立部署维护。 应用之间可以通过超链接建立管理，也可以通过消息队列进行数据分发， 当然最多的还是通过访问同一个数据存储系统来构成一个关联的完整系统。 分布式服务 由于每一个应用系统都需要执行许多相同的业务操作， 比如用户管理，session管理，那么可以将这些公用的业务提取出来，独立部署。 参考文章 大型网站技术架构 引用 记录点滴，成为更好的自己。 — weizhuo.ma","tags":[{"name":"架构","slug":"架构","permalink":"http://wiki.maweizhuo.com/tags/架构/"}],"categories":[{"name":"编程艺术","slug":"编程艺术","permalink":"http://wiki.maweizhuo.com/categories/编程艺术/"},{"name":"架构","slug":"编程艺术/架构","permalink":"http://wiki.maweizhuo.com/categories/编程艺术/架构/"}]},{"title":"composer相关","date":"2018-01-03T07:53:30.000Z","path":"posts/composer相关/","text":"背景 composer 在laravel 框架 使用中的汇总,包括安装及引入包 是什么 是 PHP 用来管理依赖（dependency）关系的工具。 你可以在自己的项目中声明所依赖的外部工具库（libraries）， Composer 会帮你安装这些依赖的库文件。 使用汇总 下载&amp;安装 sudo curl -sS https://getcomposer.org/installer | sudo php -d detect_unicode=Off 执行完会生成,composer.phar的文件 修改权限 sudo chmod a+x composer.phar 全局安装 sudo mv composer.phar /usr/local/bin/composer 国内资源 composer config -g repo.packagist composer https://packagist.phpcomposer.com 123456789#### 如果 Composer 更新仍然慢，就在项目中执行以下命令composer config repo.packagist composer https://packagist.phpcomposer.com#### 上述命令将会在当前项目中的 composer.json 文件的末尾自动添加镜像的配置信息（你也可以自己手工添加）：\"repositories\": &#123; \"packagist\": &#123; \"type\": \"composer\", \"url\" : \"https://packagist.phpcomposer.com\" &#125;&#125; laravel 常用的包 “predis/predis”:&quot;~1.0&quot;, “maatwebsite/excel”: “~2.1.0”, “nmred/kafka-php”: “0.2.*” “itsgoingd/clockwork”: “^2.0” 安装示例 以安装itsgoingd/clockwork 为例 composer 包地址 安装 composer require itsgoingd/clockwork 配置: config/app.php 12345678910// 服务提供者'providers' =&gt; [ ... Clockwork\\Support\\Laravel\\ClockworkServiceProvider::class] // 别名声明 'aliases' =&gt; [ ... 'Clockwork' =&gt; Clockwork\\Support\\Laravel\\Facade::class, ] 生成配置文件 1php artisan vendor:publish 引用 记录点滴，成为更好的自己。 — weizhuo.ma","tags":[{"name":"composer","slug":"composer","permalink":"http://wiki.maweizhuo.com/tags/composer/"},{"name":"php","slug":"php","permalink":"http://wiki.maweizhuo.com/tags/php/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://wiki.maweizhuo.com/categories/程序语言/"},{"name":"PHP","slug":"程序语言/PHP","permalink":"http://wiki.maweizhuo.com/categories/程序语言/PHP/"}]},{"title":"mysql常用汇总","date":"2017-11-22T08:53:30.000Z","path":"posts/mysql常用汇总/","text":"背景 mysql 日常使用中遇到的一些问题及总结 安装相关 创建mysql用户 新建用户，并具有远程登录的权限 grant all privileges on . to ‘langyage’@’%’ identified by ‘123456’ with grant option; 新建langyage用户并给他在所有主机登录的权限，用的密码是123456； GRANT Select ON *.* TO reader@&quot;%&quot; IDENTIFIED BY &quot;123456&quot;; 新建 reader 用户并给他在所有主机登录的权限，用的密码是123456； 删除user=’'的记录 delete from mysql.user where User=’’ 修改root密码 update mysql.user set password=PASSWORD(‘123456’) where User=‘root’; flush privileges; 导入导出数据库 导出 // mysql 导出远程数据库DF_Jubao complaint表数据 到db.sql文件中 mysqldump -h10.11.1.73 -uyangzi -P7550 -pd74u0oTw35 DF_Jubao complaint --skip-lock-tables &gt; /home/public/users/maweizhuo/www/db.sql mysqldump -h10.81.1.73 -uyangzi -P7550 -pd74u0oTw35 DF_Jubao complaint --where=“ucid=11142467” &gt; /home/public/users/maweizhuo/www/test.sql &gt; --skip-lock-tables // 跳过锁表，普通用户无锁表权限 &gt; --where=&quot;&quot; 导出某个条件下某个数据表到指定文件中 &gt; --default-character-set=utf8 导入 方法一： （1）选择数据库 mysql&gt;use abc; （2）设置数据库编码 mysql&gt;set names utf8; （3）导入数据（注意sql文件的路径） mysql&gt;source /home/abc/abc.sql; 方法二： mysql -u用户名 -p密码 数据库名 &lt; 数据库名.sql mysql -uabc_f -p abc &lt; abc.sql SQL相关 查询重复字段出现的次数 1select user_name,count(*) as count from user_table group by user_name having count&gt;1; 面试常问 为什么存储引擎 mysiam 查询比innodb 快 mysiam 和innodb ，mysiam检索快的原因是数据策略是b+树，在节点上指向物理位置的指针， 故快，而innodb是索引节点存的是主键id,所以要根据主键进行2次查找 数据库事务的四个特性及含义 数据库事务transanction正确执行的四个基本要素。 ACID,原子性(Atomicity)、一致性(Correspondence)、隔离性(Isolation)、持久性(Durability)。 原子性: 整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性: 在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。 隔离性: 隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行 相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请 求，使得在同一时间仅有一个请求用于同一数据。 持久性: 在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。 引用 记录点滴，成为更好的自己。 — weizhuo.ma","tags":[{"name":"mysql","slug":"mysql","permalink":"http://wiki.maweizhuo.com/tags/mysql/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://wiki.maweizhuo.com/categories/程序语言/"},{"name":"MYSQL","slug":"程序语言/MYSQL","permalink":"http://wiki.maweizhuo.com/categories/程序语言/MYSQL/"}]},{"title":"linux命令汇总","date":"2017-11-22T06:55:30.000Z","path":"posts/linux常用命令汇总/","text":"背景 linux 环境是多数RD必须要用的一个环境,其中一些常见的命令,也必须会使用 常用汇总 递归创建目录 mkdir -p /home/dir1/dir2 查找文件名 find /路径 -iname ‘文件名*’ 查找内容 find /usr/ -type f |xargs grep 'bind-address’ 或 grep -r ‘bind-address’ /usr tar/unzip 命令解压到指定目录 tar zxvf elasticsearch-5.4.1.tar.gz -C/usr/local/ unzip test.zip -d /root/ 查看文件最新内容 tail -f /user/log.txt 查看磁盘占用 df -lh 查看目录大小 du -sh 目录 引用 记录点滴，成为更好的自己。 — weizhuo.ma","tags":[{"name":"Linux","slug":"Linux","permalink":"http://wiki.maweizhuo.com/tags/Linux/"}],"categories":[{"name":"编程艺术","slug":"编程艺术","permalink":"http://wiki.maweizhuo.com/categories/编程艺术/"},{"name":"Linux","slug":"编程艺术/Linux","permalink":"http://wiki.maweizhuo.com/categories/编程艺术/Linux/"}]},{"title":"linux php 自带扩展编译安装","date":"2017-11-22T06:54:30.000Z","path":"posts/linux php 自带扩展编译安装/","text":"背景 php 安装自带或下载的扩展,需要编译安装 步骤 进入到PHP 源码扩展目录 cd software/tar/php-7.0.2/ext/ 进入需要安装的扩展目录比如 exif cd exif 执行phpize （ 编译前准备） /usr/local/php/bin/phpize 配置，并指向PHP配置文件位置 ./configure --with-php-config=/usr/local/php/bin/php-config make 会在当前modules目录下生成exif.so make install 会把exif.so复制到 /usr/local/php/lib/php/extensions/no-debug-non-zts-20151012/ 编辑php.ini extension = exif.so 重启服务 重启php-fpm 或Apache看phpinfo会有对应扩展 引用 记录点滴，成为更好的自己。 — weizhuo.ma","tags":[{"name":"php","slug":"php","permalink":"http://wiki.maweizhuo.com/tags/php/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://wiki.maweizhuo.com/categories/程序语言/"},{"name":"PHP","slug":"程序语言/PHP","permalink":"http://wiki.maweizhuo.com/categories/程序语言/PHP/"}]},{"title":"laravel相关","date":"2017-11-22T06:53:30.000Z","path":"posts/laravel相关/","text":"背景 laravel 日常使用中遇到的一些问题及总结 问题汇总 框架安装完需要做的事情 .env 文件创建,修改里面的配置 chmod -R 777 storage/ 如何去掉notice错误,undefined index .. 提示 当你修改php.ini 里的error_reporting 后会发现,laravel 还是会报错,因为laravel 底层对 php.ini 里的变量进行重写了。 修改地址:vendor/laravel/framework/src/Illuminate/Foundation/Bootstrap/HandleExceptions.php 修改 error_reporting(E_ALL &amp; ~E_NOTICE) session问题 现象： 登录接口 session::put(‘user_id’,1) 退出接口 session::forget(‘user_id’); 用户信息 查询 session::get(‘user_id’)，还有数据，不正常。 解决办法： 在退出接口里session::forget 或put空数据之后 再加上一行代码 session::save()即可 如何添加异常提示 位置:代码文件位置在app/Exceptions/Handler.php 1234567891011public function render($request, Exception $exception)&#123; if ($this-&gt;isHttpException($exception)) &#123; return parent::render($request, $exception); &#125;else&#123; return response()-&gt;json([ 'code'=&gt;$exception-&gt;getCode(), 'msg'=&gt;$exception-&gt;getMessage(), ] ); &#125;&#125; ubuntu 安装完之后composor 报错 现象: 通过composer安装laravel框架过程中将需要调用ext-dom，若xml扩展未安装，这也会影响我们安装laravel。 以上两个扩展是PHP7版本安装laravel所依赖也是容易被忽略的扩展， 当你安装laravel无法正常生成vendor目录时就需要检查mbstring扩展加载情况了。 解决 安装也是简单的： apt-get install php7.0-mbstring 若提示：phpunit/phpunit 5.0.x requires ext-dom * -&gt; the requested PHP extension dom is missing from your system. 则需要安装xml扩展。 apt-get install php7.0-xml group by 用法 1234ReviewMark::whereIn('package_id', $review_pid) -&gt;where('is_cancel', 1) -&gt;where(\"l4_answers\", \"!=\", '')-&gt;select(\\DB::raw('package_id,count(1) as num')) -&gt;groupBy('package_id')-&gt;get()-&gt;toArray(); laravel 定时任务不执行的问题 laravel 定时任务设置不重复执行的话会生成一个加密文件，当完成这个任务时候，会删掉这个文件。 如果不删掉的话这个任务会一直不执行。 kernel.php 里 command 里面名称的方法命名，如果包含下划线也不执行，如commad(‘m_r_diff:sync’) composer 安装 curl -sS https://getcomposer.org/installer | /data/soft/php-fpm_9000/bin/php sudo mv composer.phar /usr/local/bin/composer job 的使用 生成文件 在app目录下job 目录生成队列任务 php artisan make:job SendReminderEmail 添加到队列 a. 默认 queue::push(new SendReminderEmail()); b. 指定队列名 queue::pushOn(‘queue_name’,new SendReminderEmail()); 执行队列 a. php artisan queue:work/listen 执行/监听 b. 指定执行某个队列名 --queue参数指定 php artisan queue:work --queue='queue_name' --tries=3 --sleep=2 邮箱配置 123456MAIL_DRIVER=smtpMAIL_HOST=smtp.163.comMAIL_PORT=465MAIL_USERNAME=maweizhuo1314@163.comMAIL_PASSWORD=yourpasswordMAIL_ENCRYPTION=ssl 发送邮件乱码 1$message-&gt;attach($attachment,['as'=&gt;\"=?UTF-8?B?\".base64_encode($this-&gt;pad_filename).\"?=.doc\"]); 安装laravel a. 创建 composer create-project laravel/laravel=5.1.* --prefer-dist b. 采用国内的包管理 composer config -g repositories.packagist composer http://packagist.phpcomposer.com c. 全局配置 composer config -g secure-http false 框架安装redis 引入包 注: 需要引入的包可访问 package国内镜像官网 各种引入包下载地址 修改 项目Conposer.json文件 删除Conposer.lock 执行composer clearcache 执行composer update 执行：composer require predis/predis 框架优缺点 优点 缺点 核心ioc容器 臃肿 依赖注入思想 写一个服务默认会引入多个类 中间件 慢 composer 包管理 资源消耗大 定时脚本开发 引用 记录点滴，成为更好的自己。 — weizhuo.ma","tags":[{"name":"php","slug":"php","permalink":"http://wiki.maweizhuo.com/tags/php/"},{"name":"laravel","slug":"laravel","permalink":"http://wiki.maweizhuo.com/tags/laravel/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://wiki.maweizhuo.com/categories/程序语言/"},{"name":"PHP","slug":"程序语言/PHP","permalink":"http://wiki.maweizhuo.com/categories/程序语言/PHP/"}]},{"title":"mac 工具软件","date":"2017-11-22T06:51:30.000Z","path":"posts/mac工具软件/","text":"mac 常用工具下载地址汇总 securecrt charles 抓包工具 phpstorm 网盘地址 密码:iueh 安装参考地址 数据库管理工具 sequelpro postman 和 navicat 在我的百度云网盘 翻墙host iTerm下载 iTerm与Zsh篇 git管理工具 引用 记录点滴，成为更好的自己。 — weizhuo.ma","tags":[{"name":"tool","slug":"tool","permalink":"http://wiki.maweizhuo.com/tags/tool/"}],"categories":[{"name":"工具软件","slug":"工具软件","permalink":"http://wiki.maweizhuo.com/categories/工具软件/"},{"name":"Mac","slug":"工具软件/Mac","permalink":"http://wiki.maweizhuo.com/categories/工具软件/Mac/"}]},{"title":"Git 常用命令","date":"2017-11-22T01:51:30.000Z","path":"posts/Git 常用命令/","text":"git clone 克隆一个版本仓库命令 常用参数还有 git clone url --depth=1 (加上这个参数可以避免项目太大，下载失败； –depth=1 是指只拉取最后一次的提交结果。); git clone url new_name 生成裸仓库文件 进入git源目录 , 生成无版本控制的新文件 git archive -o latest.zip HEAD 基于最新提交建立归档文件latest.zip git init 123456git init 初始化 git branch branch_name git branch -D branch_name 删除分支 git checkout -b branch_name 新建并切换为这个分支 git pull origin master 更新 = git fetch (拉取远程代码不 自动合并) + git merge git merge 12345678// 从主干合并分支代码1. 切换到master git checkout master2. 合并代码到主干 git merge --no-ff develop --no-ff 保留该版本提交的log3. 推送到远程 git push git rebase 12345678// 从主干合并分支代码1. 切换到master git checkout master2. 合并代码到主干 git rebase develop 和merge的区别是少了一条merge commit,看起来是一个操作流程线上的3. 推送到远程 git push git push 12345678git add . git rm a.txt // 删除文件 git commit -m &apos;备注&apos; git push origin master git push origin develop （develop为远程分支名） git log git status git reset 12345678// 冲突之后 ,以下命令回退还原git reset --hard HEAD^ // 最新的一次提交git checkout 文件路径git revert 冲突放弃本地修改 的改法git reset --hardgit pull git tag 123456789git标签使用-- 新建tag v1.0 git tag -a v1.0 -m &apos;v1.0 release&apos;-- 推送tag v1.0 到远程库 git push origin v1.0-- 删除本地taggit tag -d v1.0-- 删除远程taggit push origin --delete v1.0 引用 记录点滴，成为更好的自己。 — weizhuo.ma","tags":[{"name":"Git","slug":"Git","permalink":"http://wiki.maweizhuo.com/tags/Git/"}],"categories":[{"name":"编程艺术","slug":"编程艺术","permalink":"http://wiki.maweizhuo.com/categories/编程艺术/"},{"name":"Git","slug":"编程艺术/Git","permalink":"http://wiki.maweizhuo.com/categories/编程艺术/Git/"}]},{"title":"Git 清理已追踪或未添加追踪的文件","date":"2017-11-21T01:51:30.000Z","path":"posts/Git 清理已追踪或未添加追踪的文件/","text":"git add 将文件及其修改添加到 Git 索引和追踪当中，也就是将文件快照放入暂存区当中，但我们有时候想要丢弃本次修改过并添加到暂存区的内容，或者需要删除未被追踪的文件。 git checkout git checkout 是把文件从暂存区中恢复到工作区，也就是说源文件如果被修改，再使用 git add 添加到暂存区了，git checkout 无法把他再恢复到源文件，只能恢复到暂存时的状态。 git reset git reset 可以用来重置工作区和暂存区还能更改 HEAD 指向，可以达到我们的丢弃本次修改到暂存区的目的。 1234# Usage: git reset [&lt;mode&gt;] [&lt;commit&gt;]# eg: git reset --mixed HEAD$ git reset HEAD$ git checkout . 首先使用 git reset HEAD 把暂存区重置到本次提交，再用 checkout 恢复文件到暂存区的状态，但我们暂存区已经重置了，所以实际 checkout 恢复到的是本次提交时的初始状态了。 git reset 有五种模式，不写明模式参数时，默认为 --mixed，几种模式间主要的差异在于重置的区域不同，这里总结下其异同：（表中不写的位置代表无操作） 重置工作区 重置暂存区 将 HEAD 指向指定 commit –hard √ √ √ –soft √ –mixed √ √ –merge 暂存区有文件则重置失败 √ –keep 暂存区有文件则重置失败 √ 所以刚才上面两行命令， reset 后再 checkou ，可以用 --hard 代替： 1git reset --hard HEAD git clean 顺便一提，git reset --hard 是直接重置整个工作区，所以也会把未被添加追踪的新文件也删除了；但 git checkout 是恢复，所以不会影响未添加追踪的新文件。 git clean 就是用来删除未被添加追踪的文件和文件夹的。 1234git clean -n # 将显示哪些未被追踪的文件和文件夹可以清理git clean -d # 清理未被追踪的文件夹git clean -f # 清理未被追踪的文件git clean -df # 清理未被追踪的文件和文件夹 参考资料 git reset简介 Git 工作区、暂存区和版本库 git 删除已经 add 的文件","tags":[{"name":"Git","slug":"Git","permalink":"http://wiki.maweizhuo.com/tags/Git/"}],"categories":[{"name":"编程艺术","slug":"编程艺术","permalink":"http://wiki.maweizhuo.com/categories/编程艺术/"},{"name":"Git","slug":"编程艺术/Git","permalink":"http://wiki.maweizhuo.com/categories/编程艺术/Git/"}]},{"title":"hexo安装使用","date":"2017-09-25T15:04:48.000Z","path":"posts/hexo安装使用/","text":"安装 首先需要安装node.js 和npm npm install hexo --no-optional （此参数局部安装） -g(全局安装，之后运行服务会起不来端口可能) 创建一个网站目录 &amp;&amp; 进入该目录 初始化 hexo init 安装 npm install 启动服务 hexo server 新建文章 hexo new &quot;我的第一篇文章&quot; 然后会显示生产的文件地址，进行编辑 主题配置 git clone git@github.com:litten/hexo-theme-yilia.git themes/yilia 修改 _config.yml(注意：冒号后面要空一格，否则会执行页面报错) theme: yilia 生效配置(常用的命令) hexo clean hexo g (generate) hexo s (server) 启动服务 安装git提交代码 扩展 npm install hexo-deployer-git --save 发布 hexo d (deploy) 常见问题 readme.md文件 会被解析成HTML 解决: 在根目录下_config.yml 里 12skip_render: - README.md 每次编译ico或images会丢掉 解决: 在source目录下放这些源文件,而不是在public目录下放,因为public目录是 hexo g 之后生成的。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://wiki.maweizhuo.com/tags/hexo/"}],"categories":[{"name":"编程艺术","slug":"编程艺术","permalink":"http://wiki.maweizhuo.com/categories/编程艺术/"},{"name":"个人web","slug":"编程艺术/个人web","permalink":"http://wiki.maweizhuo.com/categories/编程艺术/个人web/"}]},{"title":"点滴人生观念信条","date":"2017-09-20T12:28:21.000Z","path":"posts/点滴人生观念信条/","text":"学习生活观念，提高生活质量，拒绝直男癌 优胜劣汰，直男癌去死。 消费观念：什么层次的人用什么层次的货 不要越界追求高端，并不能达到炫耀的目的；也不要刻意低廉、过分节俭，一味去省钱，反而失去更多。 钱是赚出来的，不是省出来的，赚出来的的钱 “是为了实现一定目标的等价物”。 参见 马斯洛需求层次理论 、曹将 | 从他们分手说起。 抱目的做事而不是抱期望做事 不要报期望。 任何期望都有实现的可能，但也有落空后的失望，意志不坚的人容易被失望左右，最好是不要抱着任何好的坏的期望，而是抱着某种目的做事，想着要达成目的应该要做什么，通过目的驱动行为，通过目的驱动解决问题。 遇到问题、事件努力解决 不要想着不劳而获，也不要想着该别人做，他不做我去做就吃亏。 如果于自身利益相关，应该自我主动推动事情发展、解决问题，而不是别人不做我也不做，不要吝啬一丝力气。 遭遇灾难不要放弃，人活着就有希望 不到最后已经结束就不要放弃。 人生和生活都是需要活着才能实现，记录人生信条就是因为认为这些信条能帮助人活的更好。 考虑最坏的打算，提前做好危机准备 防人之心不可无，但不等于被害妄想症。保护自己是必要的，人不能有恃无恐。 待人和气从哪个方便来说对人对己都有好处，但是和气不等于软弱退让，而是占理但不逼迫强硬。 参考资料 马斯洛需求层次理论 曹将 | 从他们分手说起 雷斯林 | “我可以骚，你不能扰”是最没意义的口号 雷斯林 | 法律对不怕死的人无解，所以待人和气一点其实对自己也有好处 | 微信","tags":[{"name":"观念信条","slug":"观念信条","permalink":"http://wiki.maweizhuo.com/tags/观念信条/"}],"categories":[{"name":"生活闲读","slug":"生活闲读","permalink":"http://wiki.maweizhuo.com/categories/生活闲读/"}]},{"title":"CSS属性声明顺序规范","date":"2017-08-27T15:04:48.000Z","path":"posts/CSS属性声明顺序规范/","text":"CSS 属性声明顺序规范 很多 CSS 规范的属性顺序都各不一样，这东西也不像 Vue 组件属性顺序 一样有官方规范，这里记录下我目前认为合适的一种顺序。 属性分类顺序 显示方法 &amp; 布局 定位 盒模型框 外边距 边框 内边距 尺寸 文本样式 字体 文本 文字颜色 背景 轮廓 透明度 &amp; 阴影 动效 过渡 转换变形 动画 其他 伪类 &amp; 伪元素 引用 媒体查询 属性顺序列表 源自 AlloyTeam CSS Code Guide 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177[ [ \"display\", \"visibility\", \"float\", \"clear\", \"overflow\", \"overflow-x\", \"overflow-y\", \"clip\", \"zoom\" ], [ \"table-layout\", \"empty-cells\", \"caption-side\", \"border-spacing\", \"border-collapse\", \"list-style\", \"list-style-position\", \"list-style-type\", \"list-style-image\" ], [ \"position\", \"top\", \"right\", \"bottom\", \"left\", \"z-index\" ], [ \"margin\", \"margin-top\", \"margin-right\", \"margin-bottom\", \"margin-left\", \"box-sizing\", \"border\", \"border-width\", \"border-style\", \"border-color\", \"border-top\", \"border-top-width\", \"border-top-style\", \"border-top-color\", \"border-right\", \"border-right-width\", \"border-right-style\", \"border-right-color\", \"border-bottom\", \"border-bottom-width\", \"border-bottom-style\", \"border-bottom-color\", \"border-left\", \"border-left-width\", \"border-left-style\", \"border-left-color\", \"border-radius\", \"border-top-left-radius\", \"border-top-right-radius\", \"border-bottom-right-radius\", \"border-bottom-left-radius\", \"border-image\", \"border-image-source\", \"border-image-slice\", \"border-image-width\", \"border-image-outset\", \"border-image-repeat\", \"padding\", \"padding-top\", \"padding-right\", \"padding-bottom\", \"padding-left\", \"width\", \"min-width\", \"max-width\", \"height\", \"min-height\", \"max-height\" ], [ \"font\", \"font-family\", \"font-size\", \"font-weight\", \"font-style\", \"font-variant\", \"font-size-adjust\", \"font-stretch\", \"font-effect\", \"font-emphasize\", \"font-emphasize-position\", \"font-emphasize-style\", \"font-smooth\", \"line-height\", \"text-align\", \"text-align-last\", \"vertical-align\", \"white-space\", \"text-decoration\", \"text-emphasis\", \"text-emphasis-color\", \"text-emphasis-style\", \"text-emphasis-position\", \"text-indent\", \"text-justify\", \"letter-spacing\", \"word-spacing\", \"text-outline\", \"text-transform\", \"text-wrap\", \"text-overflow\", \"text-overflow-ellipsis\", \"text-overflow-mode\", \"word-wrap\", \"word-break\" ], [ \"color\", \"background\", \"background-color\", \"background-image\", \"background-repeat\", \"background-attachment\", \"background-position\", \"background-position-x\", \"background-position-y\", \"background-clip\", \"background-origin\", \"background-size\" ], [ \"outline\", \"outline-width\", \"outline-style\", \"outline-color\", \"outline-offset\", \"opacity\", \"box-shadow\", \"text-shadow\" ], [ \"transition\", \"transition-delay\", \"transition-timing-function\", \"transition-duration\", \"transition-property\", \"transform\", \"transform-origin\", \"animation\", \"animation-name\", \"animation-duration\", \"animation-play-state\", \"animation-timing-function\", \"animation-delay\", \"animation-iteration-count\", \"animation-direction\" ], [ \"content\", \"quotes\", \"counter-reset\", \"counter-increment\", \"resize\", \"cursor\", \"user-select\", \"nav-index\", \"nav-up\", \"nav-right\", \"nav-down\", \"nav-left\", \"tab-size\", \"hyphens\", \"pointer-events\" ]] 参考链接 Code Guide by @mdo RECESS | property order Code Guide by @AlloyTeam","tags":[{"name":"CSS","slug":"CSS","permalink":"http://wiki.maweizhuo.com/tags/CSS/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://wiki.maweizhuo.com/categories/程序语言/"},{"name":"CSS","slug":"程序语言/CSS","permalink":"http://wiki.maweizhuo.com/categories/程序语言/CSS/"}]},{"title":"awk 管道操作小结","date":"2017-08-25T15:04:48.000Z","path":"posts/awk 管道操作小结/","text":"背景 大致是希望使用 awk 读取一个文本文件，通过空行把文本分割成多个文本块，依次把每个文本块输入到一个程序，并把结果依次输出到指定文件。 先看文件结构： 12$ lsplus.sh data.txt 其中， plus.sh 文件内容如下： 12345#!/bin/shIFS=\" \"read a b((c=a+b)) echo $&#123;c&#125; 代码含义是从标准输入读入两个数， a 、b，返回 a+b 的结果。 123$ ./plus.sh2 3 # &lt;-- its my input5 # --&gt; its result data.txt 中的数据如下： 12345670 3030 4040 8080 100 目标是使用 awk 从 data.txt 中读入 4 组数据，分别输入到 plus.sh 中，返回 4 个结果值，并依次输入到 output.txt 中。预期结果 output.txt 如下： 12343070120180 经过 一开始，简单的思路是，awk 使用空行分割文本文件，把每组文本块通过管道输入到调用的 plus.sh 中，再把每组的结果通过重定向追加到 output.txt 文件中。 根据思路于是写出如下代码： 1$ awk -v RS=\"\" '&#123;print | \"./plus.sh &gt;&gt; output.txt\"&#125;' data.txt 然而一看结果，只有第一个分段中求出来的值； 12345$ lsplus.sh data.txt output.txt$ cat output.txt30 经过调试和单独输出，发现分段也没问题，单独 print 也是分段的没问题，于是大概猜测问题出在重定向上，除了第一个值以外的其他结果并没有被重定向到文件（此处只是当时猜测，其实不对，请看下文分析）； 通过查阅 「awk 使用管道输出到 shell 中」 的相关资料，找到问题答案： 如果在 awk 程序中打开了管道，必须先关闭该管道才能打开另一个管道。也就是说一次只能打开一个管道。 shell 命令必须被双引号引用起来。 如果打算再次在 awk 程序中使用某个文件或管道进行读写，则可能要先关闭程序，因为其中的管道会保持打开状态直至脚本运行结束。注意，管道一旦被打开，就会保持打开状态直至 awk 退出。 对于 awk output | shell input 来说，shell 接收 awk 的输出，并进行处理。需要注意的是，awk 的 output 是先缓存在 pipe 中，等输出完毕后再调用 shell 命令 处理，shell 命令只处理一次，而且处理的时机是 「awk程序结束时，或者管道关闭时（需要显式的关闭管道）」 对于刚才的问题，简单的解释就是因为管道缓存，print 的所有输出被堆到一起只传了一次给 plus.sh，而且这一次相当于传了整个文件，但 plus.sh 在读了两个数计算完后就退出了，后面的所有数都没用上，由于 plus.sh 只计算了一次，因此结果也只有一个。（并非上面猜测的结果未被重定向） 解决尝试 最初的解决尝试是使用 awk 中的 close 命令关闭文件管道，于是写出如下命令： 1$ awk -v RS=\"\" '&#123;print | \"./plus.sh &gt;&gt; output.txt\"; close(\"output.txt\")&#125;' data.txt 结果依然只有一个值。。。 继续查阅资料才知道，close 关闭时需要输入的是管道描述符，而非只是文件名，而管道描述符是包含对管道调用的整个命令在内的 shell 命令字符串，也就是说，应该是 close(&quot;./plus.sh &gt;&gt; output.txt&quot;) 。 再次尝试代码修改如下： 1234567$ awk -v RS=\"\" '&#123;print | \"./plus.sh &gt;&gt; output.txt\"; close(\"./plus.sh &gt;&gt; output.txt\")&#125;' data.txt$ cat output.txt3070120180 OK，解决问题，这句代码就是能用的了。 总结 总结下刚刚踩的坑，再做些优化； awk 中先关闭该管道才能打开另一个管道； awk output | shell input 时，awk 输出缓存到管道中，只有 awk 程序结束时，或者管道关闭时，才把缓存中的所有输出交由 shell 处理； 管道描述符是调用管道的整个 shell 命令字符串；（如在 print | &quot;./plus.sh &gt;&gt; output.txt&quot;; 中就是 &quot;./plus.sh &gt;&gt; output.txt&quot;） awk 语句中使用 shell 变量 &quot;'$var'&quot; 的形式 12var=\"test\"awk 'BEGIN&#123;print \"'$var'\"&#125;' 变量中有空格时使用 &quot;'&quot;$var&quot;'&quot; 12var=\"this is a test\" awk 'BEGIN&#123;print \"'\"$var\"'\"&#125;' 变量中有空格，并且变量当作 shell 命令执行时，使用 &quot;\\&quot;'&quot;${var}&quot;'\\&quot;&quot; 形式 12cmd=\"./plus a and b.sh\"awk 'BEGIN&#123;print | \"\\\"'\"$&#123;cmd&#125;\"'\\\"\"&#125;' 再把上面 awk 语句写入到一个脚本中，方便调用： input_test.sh 123456#!/bin/shcmd=\"$&#123;1:-\"./main.sh\"&#125;\"data=\"$&#123;2:-\"test_data.txt\"&#125;\"output=\"$&#123;3:-\"stdout.txt\"&#125;\"awk -v RS=\"\" '&#123;print $n | \"\\\"'\"$&#123;cmd&#125;\"'\\\" &gt;&gt; \\\"'\"$&#123;output&#125;\"'\\\"\";close(\"\\\"'\"$&#123;cmd&#125;\"'\\\" &gt;&gt; \\\"'\"$&#123;output&#125;\"'\\\"\")&#125;' $&#123;data&#125; 然后我们可以调用这个脚本，帮我们分割文本做输入输出。 12345# input_test.sh [command] [data-file] [output-file]$ ./input_test.sh \"./plus.exe\"# 接收三个参数，要测试的命令，数据文件，输出文件，都有默认值# ==&gt; 将自动分割 test_data.txt 中的文本块分别对 plus.exe 做输入，并把结果依次写入 stdout.txt 中 可从这里获取 input_test.sh 源文件。 参考资料 linux之awk用法 | 东方雨中漫步者","tags":[{"name":"awk","slug":"awk","permalink":"http://wiki.maweizhuo.com/tags/awk/"}],"categories":[{"name":"编程艺术","slug":"编程艺术","permalink":"http://wiki.maweizhuo.com/categories/编程艺术/"},{"name":"Linux","slug":"编程艺术/Linux","permalink":"http://wiki.maweizhuo.com/categories/编程艺术/Linux/"},{"name":"Shell","slug":"编程艺术/Linux/Shell","permalink":"http://wiki.maweizhuo.com/categories/编程艺术/Linux/Shell/"}]},{"title":"八大排序算法复杂度","date":"2017-08-25T15:04:48.000Z","path":"posts/八大排序算法复杂度/","text":"排序算法时间空间复杂度表 排序方法 平均时间 最坏时间 辅助空间 稳定性 冒泡排序 $O(n^2)$ $O(n^2)$ $O(1)$ 稳定 简单选择排序 $O(n^2)$ $O(n^2)$ $O(1)$ 稳定 直接插入排序 $O(n^2)$ $O(n^2)$ $O(1)$ 稳定 希尔排序 $O(n \\log n)$ $O(n^2)$ $O(1)$ 不稳定 堆排序 $O(n \\log n)$ $O(n \\log n)$ $O(1)$ 不稳定 并归排序 $O(n \\log n)$ $O(n \\log n)$ $O(n)$ 稳定 快速排序 $O(n \\log n)$ $O(n^2)$ $O(n \\log n)$ 不稳定 基数排序 $O(d(n+r))$ $O(d(n+r))$ $O(n)$ 稳定 注：基数排序中，d 为位数，r 为基数，n 为原数组个数。 参考资料 大话数据结构 | 程杰 Sorting Algorithms Animations 冒泡排序 | Wikipedia 选择排序 | Wikipedia 快速排序 | Wikipedia 堆排序| Wikipedia 希尔排序 | Wikipedia 归并排序 | Wikipedia 维基百科上的算法和数据结构链接很强大 | 21aspnet","tags":[{"name":"算法","slug":"算法","permalink":"http://wiki.maweizhuo.com/tags/算法/"}],"categories":[{"name":"编程艺术","slug":"编程艺术","permalink":"http://wiki.maweizhuo.com/categories/编程艺术/"},{"name":"算法","slug":"编程艺术/算法","permalink":"http://wiki.maweizhuo.com/categories/编程艺术/算法/"}]},{"title":"maweizhuo wiki site desc","date":"2017-08-25T15:04:48.000Z","path":"posts/maweizhuo wiki site desc/","text":"我的个人wiki 😊 😊。 O(∩_∩)O哈哈~ 背景 没有 wiki 的时候,自己对知识的储备流程大概如下 干脆不记录,需要时候百度下 😂 记在一个本上,方式古老了点 写博客,但相对零散,不直观 存在云笔记里,如 有道云 在使用中，笔记系统 主大块信息的分类和整理，Wiki 主零碎知识的积累，而 博客 只在于 精。 用途 希望在以后的工作生活中,wiki可以作为自己的一个工具,记录自己生活中的点滴。促进自己成长。 其他链接 github blog 我的主页 引用 记录点滴，成为更好的自己。 — weizhuo.ma Hosted by Coding Pages","tags":[],"categories":[]},{"title":"IaaS, PaaS, SaaS 概念","date":"2017-08-25T15:04:48.000Z","path":"posts/IaaS, PaaS, SaaS 概念/","text":"云服务通常将其提供的服务自下而上分成三层：基础设施(infrastructure)、平台(platform)和软件(software)。 IaaS Infrastructure-as-a-Service(基础设施即服务) 第一层叫做 IaaS，有时候也叫做 Hardware-as-a-Service，如果你想在办公室或者公司的网站上运行一些应用（比如自己开发好的 APP 或是网络游戏，你需要去买服务器，成本太高了。 但是现在有IaaS，你可以将硬件外包给这些专业的公司，这些公司会提供场外服务器，存储和网络硬件，你花钱租用就行。 这样就节省了维护成本和办公场地，并且你可以在任何时候利用这些硬件来运行其应用。 PaaS Platform-as-a-Service（平台即服务） 第二层就是 PaaS，某些时候也叫做中间件。PaaS 是面向软件开发者的服务，云计算平台提供硬件，OS， 编程语言，开发库，部署工具， 帮助软件开发者更快的开发软件服务。 云服务商将软件开发的云端开发平台和软件运营的云端运行环境（包括中间件、数据库、we b服务、消息总线等基础通用服务）作为一种服务，提供给最终用户。 换句话说，这些 PaaS 服务商提供的都是基础开发服务平台，主要目的就是让你把精力专注在应用层面的开发上面，而不需要浪费在这些基础重复性的事情上，也不用担心开发完成后部署问题。 SaaS Software-as-a-Service（软件即服务） 简单说就是人家把你想要的功能开发好成应用软件，然后直接卖账号给你用，你也不需要担心服务器、带宽、应用开发等问题，直接交钱使用就行。 不再面向开发，而是直接面向企业或普通用户，企业改改 logo，直接给用户使用。 参考资料 IaaS PaaS和SaaS公司的作用 | 盐漂浮草 谁能举个通俗易懂的例子告诉我IAAS，SAAS，PAAS的区别？ | 东坪子的回答 谁能举个通俗易懂的例子告诉我IAAS，SAAS，PAAS的区别？ | 何足道的回答","tags":[{"name":"云服务","slug":"云服务","permalink":"http://wiki.maweizhuo.com/tags/云服务/"}],"categories":[{"name":"编程艺术","slug":"编程艺术","permalink":"http://wiki.maweizhuo.com/categories/编程艺术/"},{"name":"架构","slug":"编程艺术/架构","permalink":"http://wiki.maweizhuo.com/categories/编程艺术/架构/"}]},{"title":"DISC 行为风格理论","date":"2017-08-16T04:56:24.000Z","path":"posts/DISC-行为风格理论/","text":"什么是 DISC DISC 是一种行为风格理论，它将人的行为通过四个维度来解释。现代 DISC 是由美国心理学家威廉·莫尔顿·马斯顿博士（Dr. William Moulton Marston）在二十世纪二十年代提出的理论基础发展和延伸来的。DISC 四个字母各表示一个维度，其具体解释各家略有差别。四个属性简单概括如下： D : Dominance / Director , 老板型 / 指挥者，表现为目标明确、执行力强。 I : Influence / Interact , 互动型 / 社交者，表现为热爱分享、性格活泼。 S : Steadiness / Supporter , 支持型 / 支持者，表现为对人依赖和迁就。 C : Corrector / Compliance , 修正型 / 思考者，现为标准清晰、追求卓越。 DISC 是对人行为、情绪、性格的归纳，既可以说某人是 D 类型的性格，也可以说某人这个行为偏 D 属性。每个人都有 DISC 方面的四个属性，只是偏向性不同，是行为风格的一种特点，每种熟悉之间没有好坏之分，并且可以易于通过训练改变偏向的属性特质。 DISC 理论中既包括每个属性都有哪些特质，也包括每种属性的人心里对人对事的期望，和如何正确对各种属性的人打交道。 DISC 有什么作用 因为 DISC 跟人性格的强相关性，最常见的使用就是通过 DISC 理论分析周围人的性格属性，采用适用的沟通方式减少交流障碍与矛盾；很多时候你在人群中不受欢迎，是因为没有采取对味的谈话方式给不同 DISC 属性的人。 延伸上讲，DISC 覆盖的范围就很广了； 与人力资源挂钩，企业管理通过了解职员的特性，进而分配合适的任务，放对人才位置提升人力效率； 与自我分析挂钩，细致分析自我的 DISC 属性偏向再回顾过去，能很容易解释以往做错事的原因，这时总结自己 DISC 属性方面的缺失，能够预测自己在遇到某类问题时容易犯什么错，针对性的训练自己某个缺失的属性，完善和规整自身行为。 与演讲演示挂钩，通过 DISC 分析现场观众成分，调整演讲者说话内容的属性，帮助调动现场氛围，更吸引人。 与对话谈判挂钩，分析对手缺失的属性，判断对手到底是吃哪套的人，直击谈判痛点，反转局势。 与人生规划挂钩，了解自己，才能给自己规划合适的方向，不断调整、学习和发展。 DISC 的应用非常之多，是涵盖社区交往多数场合的常用技能。 如何分析人的 DISC 属性 上面有简单介绍 DISC 属性的特质，这里也先放上一张总结性的属性表。 企业中常用的识别方式是通过让职员使用网页或软件做 DISC 测评，通过软件分析得出员工属性偏向； 日常生活中肯定是没办法让你身边的每个人都做一套测评题的，但是我们也可以通过观察他人的言行，说话风格做事风格，来简单分析某个人处于这个场景中更偏向哪种属性。相处方法符合“同性相吸”，即他是什么特质的人，你就按那个特质的行为方式来回应他，一般都会让他满意，两方相处都舒服。 D 属性 属性特质： 关注事情发展 能力强，态度偏强势，自主积极推动事情 目标坚定，认定的事情不容易改 喜欢定计划，追求办事效率 做事不留情面（不会照顾感情） 常见于老板领导特质 沟通要点： 第一，计划性要强 第二，避免正面争论 第三，汇报要点 第四，如果做错了，及时承认 考虑使用“三点汇报法” 最重要的是什么 最紧急的是什么 列完整清单 I 属性 属性特质： 关注人的情绪变化 喜欢与人交谈而不是刻板做事 社交主动，乐于分享 喜欢听故事讲故事，善于描述细节，喜欢夸张性的形容词 回应人热情、积极及时 常见于社交达人特质 沟通要点： 第一，热情回应 第二，告诉他“你有趣” 第三，多用具体的人和事来表达 第四，多表达感受 第五，不要跟他们谈“人不为己天诛地灭” S 属性 属性特质： 随和，中庸，没有棱角 比较关注人的行为 喜欢在后面支持帮助他人，不善于正面出风头 服从安排 喜欢和平，害怕冲突矛盾 话不多说，做事稳健，不会急躁，谨言慎行 长久保持一致，固有原则，不喜欢改变 沟通要点： 第一，多说一两句温暖和肯定的话 第二，多一些关怀和包容 第三，多一些指导给出规划 C 属性 属性特质： 关注事情方向的把控 喜欢标准化，善于分析规则 总跟他人摆事实讲道理 先思考后做事情 喜欢简洁（外观和流程） 喜欢定计划，按步就搬，也要求别人要守规矩 追求完美卓越，对人对事要求高 情感内敛，有话直说，按规矩办事而不受感情影响 表情严肃，给人一定不易接近的距离感 沟通要点： 第一，用数据和事实说话 第二，保持距离，不用套近乎 第三，让他们先发言 第四，有话直说但一定要符合逻辑 场景举例 D 属性 这个项目已经进展到核心环节，目前最重要的是做尽职调查，完善财务数据；（最重要的是什么） 当前最紧急的事是跟对方领导沟通，安排一次碰头会；（最紧急的是什么） 其他相关的进度在这张表上，我马上发送到您的邮箱，有任何问题可以随时联系我。（完整清单） I 属性 I：“我发现有个新的APP，真的超有用，你看看……” “恩，真的哎！我马上去下！”（及时热情反馈） S 属性 “我记得琶醍有家餐馆不错，晚上一起去吃吧，不要说拒绝哦！”（有安排，并表现照顾） C 属性 直接陈述道理和事实即可。 参考资料 李海峰说DISC 李海峰：DISC帮领导者巧用人用对人 曹将：DISC 分析简述 | 微信 曹将：DISC 与人际沟通 | 微信","tags":[{"name":"生活闲读","slug":"生活闲读","permalink":"http://wiki.maweizhuo.com/tags/生活闲读/"},{"name":"DISC","slug":"DISC","permalink":"http://wiki.maweizhuo.com/tags/DISC/"}],"categories":[{"name":"生活闲读","slug":"生活闲读","permalink":"http://wiki.maweizhuo.com/categories/生活闲读/"}]}]}